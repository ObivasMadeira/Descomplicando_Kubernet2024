Iniciar o pick 2024 - criando um docker do zero sem usar o docker hehehe (ambiente isolado)

Primeira ferramenta utilizada é o :

apt-get install debootstrap
Esse cara é utilizado para baixar um sistema inteiro para dentro do seu sistema, criar um sistema de arquivos dentro do seu sistema.

O comando a seguir é baixar trazer o sistema escolhido por vc para dentro da sua máquina, no exemplo usamos o debian:
Esse comando ira realizar o download de td o sistema de diretórios necessários para rodar o debian dentro do seu sistema, no exemplo ele esta colocando td na pasta /debian

debootstrap stable /debian http://deb.debian.org/debian

O comando a seguir é para subir o sistema debian dentro da pasta debian que foi criada
unshare --mount --uts --ipc --net --map-root-user --user --pid --fork chroot /debian bash

-mount: Isola o namespace de montagem do sistema de arquivos. Isso significa que o processo que está sendo executado dentro do namespace unshare terá seu próprio ponto de montagem, separado do restante do sistema.
-uts: Isola o namespace de identificação do sistema (UTS). Isso permite que o processo tenha seu próprio hostname e informações de identificação do sistema, separados do restante do sistema.
-ipc: Isola o namespace de comunicação interprocessual (IPC). Isso significa que o processo terá seu próprio conjunto de recursos IPC, como filas de mensagens e semáforos, isolados do restante do sistema.
-net: Isola o namespace de rede. Isso permite que o processo tenha sua própria pilha de rede, interfaces de rede e tabelas de roteamento, separadas do restante do sistema.
-map-root-user: Mapeia o ID de usuário dentro do namespace unshare para o ID de usuário 0 (root). Isso significa que, mesmo que o processo seja executado com um ID de usuário diferente fora do namespace unshare, dentro dele será tratado como root.
-user: Isola o namespace de usuário. Isso permite que o processo tenha seu próprio conjunto de IDs de usuário e grupos, isolados do restante do sistema.
-pid: Isola o namespace de PID (identificadores de processo). Isso permite que o processo tenha sua própria árvore de processos, separada do restante do sistema.
-fork: Esta opção não é específica do unshare, mas sim do comando chroot. Ela instrui o comando chroot a criar um novo processo filho após mudar para o diretório raiz especificado.
O comando chroot /debian bash no final do seu comando está mudando o diretório raiz para /debian e executando o shell Bash dentro desse novo ambiente raiz. Isso cria um novo ambiente isolado onde o shell Bash é executado com suas próprias configurações e recursos, de acordo com as opções fornecidas pelo unshare.

Outro exemplo para testa o isolamento de recursos é rodar os comandos
ip a
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
nesse caso ele não trouxe informação de rede pq não esta configurado no debian, mas se rodar o comando sem o --net, no caso sem isolamento de rede ele ira retornar as informações de rede da máquina local



Após executar o comando iremos adentrar dentro do sistema debian.
Se execurtamos o comando 
ps -ef
sera retornado o erro de 
"Error, do this: mount -t proc proc /proc"
Esse erro é referente pq o /proc não esta montando, nesse exemplo iremos montar o /proc com o seguinte comando
mount -t proc none /proc
Após a execução do mesmo e realizar o comando 
ps -ef novamente, será exibido o seguinte resultado
root@obi-System-Product-Name:/# ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 18:56 ?        00:00:00 bash
root           4       1  0 18:57 ?        00:00:00 ps -ef

Podemos tb montar mais, como por exemplo
mount -t sysfs none /sys
mount -t tmpfs none /tmp

Após essa sequencia de comando, nós criamos um isolamento no caso um container.

=======================================================
Material aula

Namespaces

Namespaces foram adicionados no kernel Linux na versão 2.6.24 e são eles que permitem o isolamento de processos quando estamos utilizando o Docker. São os responsáveis por fazer com que cada container possua seu próprio environment, ou seja, cada container terá a sua árvore de processos, pontos de montagens, etc., fazendo com que um container não interfira na execução de outro. Vamos saber um pouco mais sobre alguns namespaces utilizados pelo Docker.

PID namespace
O PID namespace permite que cada container tenha seus próprios identificadores de processos. Isso faz com que o container possua um PID para um processo em execução -- e quando você procurar por esse processo na máquina host o encontrará; porém, com outra identificação, ou seja, com outro PID.

A seguir temos o processo "testando.sh" sendo executado no container.

Perceba o PID desse processo na árvore de processos dele:

root@c774fa1d6083:/# bash testando.sh &
[1] 7

root@c774fa1d6083:/# ps -ef
UID  PID PPID C STIME TTY TIME     CMD
root 1   0    0 18:06 ?   00:00:00 /bin/bash
root 7   1    0 18:07 ?   00:00:00 bash testando.sh
root 8   7    0 18:07 ?   00:00:00 sleep 60
root 9   1    0 18:07 ?   00:00:00 ps -ef

root@c774fa1d6083:/#
Agora, perceba o PID do mesmo processo exibido através do host:

root@linuxtips:~# ps -ef | grep testando.sh

root 2958 2593 0 18:12 pts/2 00:00:00 bash testando.sh
root 2969 2533 0 18:12 pts/0 00:00:00 grep --color=auto testando.sh

root@linuxtips:~#
Diferentes, né? Porém, são o mesmo processo. :)

Net namespace
O Net Namespace permite que cada container possua sua interface de rede e portas. Para que seja possível a comunicação entre os containers, é necessário criar dois Net Namespaces diferentes, um responsável pela interface do container (normalmente utilizamos o mesmo nome das interfaces convencionais do Linux, por exemplo, a eth0) e outro responsável por uma interface do host, normalmente chamada de veth* (veth + um identificador aleatório). Essas duas interfaces estão linkadas através da bridge Docker0 no host, que permite a comunicação entre os containers através de roteamento de pacotes.

Conforme falamos, veja as interfaces. Interfaces do host:

root@linuxtips:~# ip addr

1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default
       link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
       inet 127.0.0.1/8 scope host lo
           valid_lft forever preferred_lft forever
       inet6 ::1/128 scope host
           valid_lft forever preferred_lft forever
2: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
        link/ether 00:1c:42:c7:bd:d8 brd ff:ff:ff:ff:ff:ff
        inet 10.211.55.35/24 brd 10.211.55.255 scope global eth1
            valid_lft forever preferred_lft forever
        inet6 fdb2:2c26:f4e4:0:21c:42ff:fec7:bdd8/64 scope global dynamic
            valid_lft 2591419sec preferred_lft 604219sec
        inet6 fe80::21c:42ff:fec7:bdd8/64 scope link
            valid_lft forever preferred_lft forever
3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
        link/ether 02:42:c7:c1:37:14 brd ff:ff:ff:ff:ff:ff
        inet 172.17.0.1/16 scope global docker0
            valid_lft forever preferred_lft forever
        inet6 fe80::42:c7ff:fec1:3714/64 scope link
            valid_lft forever preferred_lft forever
5: vetha2e1681: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP group default
        link/ether 52:99:bc:ab:62:5e brd ff:ff:ff:ff:ff:ff
        inet6 fe80::5099:bcff:feab:625e/64 scope link
             valid_lft forever preferred_lft forever
root@linuxtips:~#
Interfaces do container:

root@6ec75484a5df:/# ip addr

1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default
        link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
        inet 127.0.0.1/8 scope host lo
            valid_lft forever preferred_lft forever
        inet6 ::1/128 scope host
            valid_lft forever preferred_lft forever
6: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
        link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff
        inet 172.17.0.3/16 scope global eth0
            valid_lft forever preferred_lft forever
        inet6 fe80::42:acff:fe11:3/64 scope link
            valid_lft forever preferred_lft forever

root@6ec75484a5df:/#
Conseguiu visualizar as interfaces Docker0 e veth* do host? E a eth0 do container? Sim? Otémooo! :D

Mnt namespace
É evolução do chroot. Com o Mnt Namespace cada container pode ser dono de seu ponto de montagem, bem como de seu sistema de arquivos raiz. Ele garante que um processo rodando em um sistema de arquivos não consiga acessar outro sistema de arquivos montado por outro Mnt Namespace.

IPC namespace
Ele provê um SystemV IPC isolado, além de uma fila de mensagens POSIX própria.

UTS namespace
Responsável por prover o isolamento de hostname, nome de domínio, versão do SO, etc.

User namespace
O mais recente namespace adicionado no kernel Linux, disponível desde a versão 3.8. É o responsável por manter o mapa de identificação de usuários em cada container.

=================================================================
CGROUP, utilizado para criar limitação de recurso, quando que pode ser usado, no exemplo iremos criar uma limitação do uso de cpu

getconf _NPROCESSORS_ONLN (comando para listar o números de CPU)

cgset -r cpu.cfs_quota_us=1000 giro (giro = ao novo cgroup criado com o comando "sudo cgcreate -g cpu,cpuacct,memory,blkio,devices,freezer:giros"
nesse comando estamos informando que é para usar 1% ta cpu no container.

===================================================================
Copy-On-Write (COW) e Docker
Antes de entender as camadas propriamente ditas, precisamos entender como um dos principais requisitos para essa coisa acontecer, o Copy-On-Write (ou COW para os íntimos), funciona. Nas palavras do próprio Jérome Petazzoni:
It's a little bit like having a book. You can make notes in that book if you want, but each time you approach the pen to the page, suddenly someone shows up and takes the page and makes a xerox copy and hand it back to you, that's exactly how copy on write works.
Em tradução livre, seria como se você tivesse um livro e que fosse permitido fazer anotações nele caso quisesse, porém, cada vez que você estivesse prestes a tocar a página com a caneta, de repente alguém aparecesse, tirasse uma xerox dessa página e entregasse a cópia para você. É exatamente assim que o Copy-On-Write funciona.
Basicamente, significa que um novo recurso, seja ele um bloco no disco ou uma área em memória, só é alocado quando for modificado.
Tá, mas o que isso tudo tem a ver com o Docker? Bom, como você sabe, o Docker usa um esquema de camadas, ou layers, e para montar essas camadas são usadas técnicas de Copy-On-Write. Um container é basicamente uma pilha de camadas compostas por N camadas read-only e uma, a superior, read-write.

====================================================================






