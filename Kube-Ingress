Hj vamos falar do ingress.

Se você está aqui, provavelmente já tem alguma noção do que o Kubernetes faz. Mas como expor seus serviços ao mundo externo de forma eficiente e segura? É aí que entra o nosso protagonista do dia: o Ingress. 
Nesta seção, vamos desvendar o que é o Ingress, para que serve e como ele se diferencia de outras formas de expor aplicações no Kubernetes.

==================================
O que é o Ingress?

O Ingress é um recurso do Kubernetes que gerencia o acesso externo aos serviços dentro de um cluster. Ele funciona como uma camada de roteamento HTTP/HTTPS, 
permitindo a definição de regras para direcionar o tráfego externo para diferentes serviços back-end. 
O Ingress é implementado através de um controlador de Ingress, que pode ser alimentado por várias soluções, como NGINX, Traefik ou Istio, para citar alguns.

Tecnicamente, o Ingress atua como uma abstração de regras de roteamento de alto nível que são interpretadas e aplicadas pelo controlador de Ingress. 
Ele permite recursos avançados como balanceamento de carga, SSL/TLS, redirecionamento, reescrita de URL, entre outros.
Principais Componentes e Funcionalidades:

    Controlador de Ingress: É a implementação real que satisfaz um recurso Ingress. Ele pode ser implementado através de várias soluções de proxy reverso, como NGINX ou HAProxy.

    Regras de Roteamento: Definidas em um objeto YAML, essas regras determinam como as requisições externas devem ser encaminhadas aos serviços internos.

    Backend Padrão: Um serviço de fallback para onde as requisições são encaminhadas se nenhuma regra de roteamento for correspondida.

    Balanceamento de Carga: Distribuição automática de tráfego entre múltiplos pods de um serviço.

    Terminação SSL/TLS: O Ingress permite a configuração de certificados SSL/TLS para a terminação de criptografia no ponto de entrada do cluster.

    Anexos de Recurso: Possibilidade de anexar recursos adicionais como ConfigMaps ou Secrets, que podem ser utilizados para configurar comportamentos adicionais como autenticação básica, listas de controle de acesso etc.
==============================
Para testarmos o Ingress no Kind é necessários algumas configurações no momento de criar o cluster Kind.

cluster_ingress.yaml

kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  kubeadmConfigPatches:
  - |
    kind: InitConfiguration
    nodeRegistration:
      kubeletExtraArgs:
        node-labels: "ingress-ready=true"
  extraPortMappings:
  - containerPort: 80
    hostPort: 80
    protocol: TCP
  - containerPort: 443
    hostPort: 443
    protocol: TCP

Com essa configuração vamos continuar com a nossa aula.

==========================

Instalando um Ingress Controller

Vamos continuar usando o Nginx Ingress Controller como exemplo, que é amplamente adotado e bem documentado.

kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/kind/deploy.yaml

Você pode utilizar a opção wait do kubectl, assim quando os pods estiverem prontos, ele irá liberar o shell, veja:

kubectl wait --namespace ingress-nginx \
  --for=condition=ready pod \
  --selector=app.kubernetes.io/component=controller \
  --timeout=90s

No comando acima, estamos esperando que os pods do Ingress Controller estejam prontos, 
com o label app.kubernetes.io/component=controller, no namespace ingress-nginx, e caso não estejam prontos em 90 segundos, o comando irá falhar.

========================================
Vamos criar um deployment da aplicação giropops senha, na namespace obivas

apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: giropops-senhas
  name: giropops-senhas
  namespace: obivas
spec:
  replicas: 2
  selector:
    matchLabels:
      app: giropops-senhas
  template:
    metadata:
      labels:
        app: giropops-senhas
    spec:
      containers:
      - name: giropops-senhas
        image: linuxtips/giropops-senhas:1.0
        ports:
        - containerPort: 5000
        imagePullPolicy: Always
~                                                                                                                                                                                                                                      
~                                     
kubectl get pods -n obivas
NAME                               READY   STATUS    RESTARTS   AGE
giropops-senhas-69c89f4c5d-bwv5g   1/1     Running   0          81s
giropops-senhas-69c89f4c5d-dt2vp   1/1     Running   0          82s

Vamos criar tb um service

apiVersion: v1
kind: Service
metadata:
  name: giropops-senhas
  labels:
    app: giropops-senhas
spec:
  type: ClusterIP
  selector:
    app: giropops-senhas
  ports:
    - name: tcp-app
      protocol: TCP
      port: 5000
      targetPort: 5000

Agora vamos criar o redis e seu service

apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-deployment
  labels:
    app: redis
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
        - name: redis
          image: redis
          ports:
            - containerPort: 6379
          resources:
            requests:
              cpu: "100m"
              memory: "128Mi"
            limits:
              cpu: "250m"
              memory: "256Mi"
---
apiVersion: v1
kind: Service
metadata:
  name: redis
  labels:
    app: redis
spec:
  ports:
    - port: 6379
      targetPort: 6379
  selector:
    app: redis
  type: ClusterIP

Outra coisa importante é alterar no deployment do giropos-senhas, pois temo q adicionar ENV para se conectar ao serviço do redis foi adicionado:

"env:
        - name: REDIS_HOST
          value: redis"

apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: giropops-senhas
  name: giropops-senhas
  namespace: obivas
spec:
  replicas: 2
  selector:
    matchLabels:
      app: giropops-senhas
  template:
    metadata:
      labels:
        app: giropops-senhas
    spec:
      containers:
      - name: giropops-senhas
        env:
        - name: REDIS_HOST
          value: redis
        image: linuxtips/giropops-senhas:1.0
        ports:
        - containerPort: 5000
        imagePullPolicy: Always
~                                                               
Criando o ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: giropops-senhas
  annotations:
    nginx.ingress.kubernetes.oi/rewrite-target: /
spec:
  rules:
  - http:
      paths:
      - path: /giropops-senhas
        pathType: Prefix
        backend:
          service:
            name: giropops-senhas
            port:
              number: 5000
k apply -f ingress.yaml
kubectl get ingress
NAME              CLASS    HOSTS   ADDRESS   PORTS   AGE
giropops-senhas   <none>   *                 80      11m

Após tds esses passo a aplicação respondeu no navagador usando 
localhost/giropops-senhas
mas a mesma retornou quebrada, erro ocorre porque o link do logo aponta para /, mas o Ingress só serve /giropops-senhas.
Corrijimos o link do logo para /giropops-senhas.
ingress.yaml alterada pra funcionar hehehehe

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: giropops-senhas
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - http:
      paths:
      - path: /giropops-senhas(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: giropops-senhas
            port:
              number: 5000
      - path: /
        pathType: Prefix
        backend:
          service:
            name: giropops-senhas
            port:
              number: 5000





